# Decorator Pattern (裝飾器模式)

> **裝飾器模式**是一種結構型設計模式，可以動態地為物件附加額外的職責。

### 裝飾器模式結構

![裝飾器模式結構](./%E8%A3%9D%E9%A3%BE%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%A7%8B.png?raw=true)

### 裝飾器模式的應用場景

1. **如果你希望在無需修改程式碼的情況下即可使用對象，並且希望在運行時為對象增加額外的"行為"**
    > 裝飾器模式能將業務邏輯組織成層次結構，可以為各層創建一個裝飾，在運行期間將各種不同的邏輯組合成對象。這些對象都遵循通用介面，客戶端地程式碼能以相同方式使用對象。
2. **如果用繼承來擴展對象行為的方案難以實現**
    > 許多程式使用final限制類的進一步擴展，復用最終類已有的行為的唯一方法就是裝飾器模式：用封裝器對其進行封裝。

### 優缺點

:o:**優點**

1. 無須創建新子類即可擴展對象的行為
2. 可以在運行期間添加或刪除對象的功能
3. 可以用多個裝飾封裝對象來組合多種行為
4. 單一職責原則。可以將實現了許多不同行為的一個大類，拆分成許多較小的類

:x:**缺點**

1. 在裝飾器stack中刪除特定的裝飾器比較困難
2. 實現行為不受裝飾stack順序影響的裝飾比較困難
3. 各層的初始化配置程式碼看上去可能會很糟糕

## 原始的模型架構與需求

1. 創立初期，使用抽象介面定義飲料(Beverage)，並只有幾種子類。
2. cost()由子類別實作，用來回傳飲料的價格。

![]()

### 遇到的問題

1. 因為飲料增加了調味料，如牛奶、豆漿、摩卡、奶泡。根據不同的調味品加收不同的費用，造成**類別大爆炸**。
